/* Задача:
Input:

Строка из n положительных чисел (n = 0 или n > = 2).

Назовем вес числа суммой его цифр. Например, 99 будет иметь «вес» 18, 100 будет иметь «вес» 1.

Два числа «близки», если разница их весов мала.

Ваша задача:
Для каждого числа в strng вычислите его «вес», а затем найдите два числа в strng, которые имеют наименьшую разницу весов, т.е., которые являются ближайшими с наименьшим весом и с наименьшими индексами (или рангами, пронумерованными от 0) в strng.

Output:

Массив из двух массивов, каждый из которых находится в следующем формате:
[номер-вес, индекс в строке соответствующего номера, исходный соответствующий номер элемента].

Два подмассива сортируются в порядке возрастания по их количественным весам, если эти веса разные, или по их индексам в строке, если они имеют одинаковые веса.

Примеры:
Давайте назовем эту функцию closest().

strng = "103 123 4444 99 2000"
веса 4, 6, 16, 18, 2 (т.е. 2, 4, 6, 16, 18)

closest() должна вернуть [[2, 4, 2000], [4, 0, 103]],
потому что 2000 и 103 имеют вес 2 и 4, в индексе есть 4 и 0.
Наименьшая разница составляет 2.
4 (для 103) и 6 (для 123) тоже имеют разность 2, но они не самые маленькие с разницей 2 между их весами.
....................

strng = "80 71 62 53"
Все веса 8.
closest() должна вернуть [[8, 0, 80], [8, 1, 71]]
71 и 62 также имеют:
- наименьший вес (это 8 для всех)
- наименьшая разница весов (которая равна 0 для всех пар)
- но не самые маленькие показатели в структуре.
....................

strng = "444 2000 445 544"
веса 12, 2, 13, 13 (то есть 2, 12, 13, 13)
closest() должна вернуть [[13, 2, 445], [13, 3, 544]]
444 и 2000 имеют наименьшие веса (12 и 2), но не наименьшую разницу весов;
Они не самые близкие.
Здесь наименьшая разница равна 0, и в результате индексы располагаются в порядке возрастания.
...................

closest(«444 2000 445 644 2001 1002») -> [[3, 4, 2001], [3, 5, 1002]]
Здесь наименьшая разница равна 0, и в результате индексы располагаются в порядке возрастания.
...................

closest("239382 162 254765 182 485944 468751 49780 108 54")
Веса: 27, 9, 29, 11, 34, 31, 28, 9, 9.
closest() должна вернуть [[9, 1, 162], [9, 7, 108]]
108 и 54 имеют наименьшую разницу весов, они также имеют
наименьшие веса, но они не имеют наименьших рангов в исходной строке.
..................

closest("54 239382 162 254765 182 485944 468751 49780 108")
closest() должна вернуть [[9, 0, 54], [9, 2, 162]]

Внимание:
Если n == 0, closest("") должна вернуть []
*/

function closest(strng) {
  if (strng.length == 0) return [];
  let arr = strng.split(" ");
  let sumEl = [];
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      sum += +arr[i][j];
    }
    sumEl.push(sum);
    sum = 0;
  }
  let sumElSort = sumEl.sort((prev, next) => prev - next);
  let minDiff = sumElSort[1] - sumElSort[0];
  let elSelected = [];
  for (let i = 0; i < sumElSort.length; i++) {
    if (sumElSort[i + 1] - sumElSort[i] == 0) {
      minDiff = 0;
      break;
    }
    if (sumElSort[i + 1] - sumElSort[i] < minDiff) {
      minDiff = sumElSort[i + 1] - sumElSort[i];
    }
  }
  for (let i = 0; i < sumElSort.length; i++) {
    if (sumElSort[i + 1] - sumElSort[i] == minDiff) {
      elSelected.push(sumElSort[i]);
      elSelected.push(sumElSort[i + 1]);
      break;
    }
  }
  let res1 = [];
  let res2 = [];
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      sum += +arr[i][j];
    }
    if (sum == elSelected[0]) {
      res1.push(i);
      res1.push(+arr[i]);
    }
    if (sum == elSelected[1]) {
      res2.push(i);
      res2.push(+arr[i]);
    }
    sum = 0;
  }
  if (elSelected[0] == elSelected[1])
    return [
      [elSelected[0], res1[0], res1[1]],
      [elSelected[0], res1[2], res1[3]],
    ];
  return [
    [elSelected[0], res1[0], res1[1]],
    [elSelected[1], res2[0], res2[1]],
  ];
}

console.log(closest("")); // expected []
console.log(closest("456899 50 11992 176 272293 163 389128 96 290193 85 52")); // expected [[13, 9, 85], [14, 3, 176]]
console.log(closest("239382 162 254765 182 485944 134 468751 62 49780 108 54")); // expected [[8, 5, 134], [8, 7, 62]]
console.log(
  closest("241259 154 155206 194 180502 147 300751 200 406683 37 57")
); // expected [[10, 1, 154], [10, 9, 37]]
console.log(closest("89998 187 126159 175 338292 89 39962 145 394230 167 1")); // expected [[13, 3, 175], [14, 9, 167]]
console.log(
  closest("462835 148 467467 128 183193 139 220167 116 263183 41 52")
); // expected [[13, 1, 148], [13, 5, 139]]
console.log(closest("403749 18 278325 97 304194 119 58359 165 144403 128 38")); // expected [[11, 5, 119], [11, 9, 128]]
console.log(closest("28706 196 419018 130 49183 124 421208 174 404307 60 24")); // expected [[6, 9, 60], [6, 10, 24]]
console.log(closest("189437 110 263080 175 55764 13 257647 53 486111 27 66")); // expected [[8, 7, 53], [9, 9, 27]]
console.log(closest("79257 160 44641 146 386224 147 313622 117 259947 155 58")); // expected [[11, 3, 146], [11, 9, 155]]
console.log(closest("315411 165 53195 87 318638 107 416122 121 375312 193 59")); // expected [[15, 0, 315411], [15, 3, 87]]
