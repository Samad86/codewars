/*
Реализовать zipWith

zipWith принимает функцию и два массива и связывает их вместе, применяя функцию к каждой паре значений.
Значение функции - один новый массив.

Если массивы имеют неодинаковую длину, результат будет такой же длины, что и самый короткий.
(Значения более длинного массива просто не используются).

Входные данные не должны изменяться.

Примеры:
zipWith(Math.pow, [10, 10, 10, 10], [0, 1, 2, 3]) => [1, 10, 100, 1000]
zipWith(Math.max, [1, 4, 7, 1, 4, 7], [4, 7, 1, 4, 7, 1]) => [4, 7, 7, 4, 7, 7]

zipWith(function (a, b) {return a + b;}, [0, 1, 2, 3], [0, 1, 2, 3]) => [0, 2, 4, 6] Обе формы являются действительный.
zipWith((a, b) => a + b, [0, 1, 2, 3], [0, 1, 2, 3]) => [0, 2, 4, 6] Оба являются функциями.

Проверка ввода:
Предположим, что все данные действительны.
*/

function zipWith(fn, a0, a1) {
  let arr = [];
  let short = Math.min(a0.length, a1.length);

  for (let i = 0; i < short; i++) {
    arr.push(fn(a0[i], a1[i]));
  }

  return arr;
}

console.log(
  zipWith(
    function (a, b) {
      return a + b;
    },
    [0, 1, 2, 3],
    [0, 1, 2, 3],
  ),
); // expected [0, 2, 4, 6]
console.log(zipWith((a, b) => a + b, [0, 1, 2, 3], [0, 1, 2, 3])); // expected [0, 2, 4, 6]
console.log(zipWith((a, b) => a + b, [0, 1, 2, 3, 4, 5], [6, 5, 4, 3, 2, 1])); // expected [6, 6, 6, 6, 6, 6]
console.log(zipWith((a, b) => a + b, [0, 1, 2, 3, 4], [6, 5, 4, 3, 2, 1])); // expected [6, 6, 6, 6, 6]
console.log(zipWith((a, b) => a + b, [0, 1, 2, 3, 4, 5], [6, 5, 4, 3, 2])); // expected [6, 6, 6, 6, 6]
console.log(zipWith((a, b) => a ** b, [10, 10, 10, 10], [0, 1, 2, 3])); // expected [1, 10, 100, 1000]
console.log(zipWith((a, b) => Math.max(a, b), [1, 4, 7, 1, 4, 7], [4, 7, 1, 4, 7, 1])); // expected [4, 7, 7, 4, 7, 7]
